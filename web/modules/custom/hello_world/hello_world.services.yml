# Il est temps de la définir notre class salutation comme un service.

# Il y a essentiellement deux façons - statiquement et injectées de utiliser les services.
# 1 - Statiquement, vous utiliseriez la Drupal classe globale pour instancier un service:
#     $service = \Drupal::service('hello_world.salutation');

# 2 - Quelques services populaires ont également des méthodes abrégées sur la \Drupalclasse : par exemple:
#      \Drupal::entityTypeManager().

services:
  hello_world.salutation: # nom de service best pratice de commance avec le nom de module.
    class: Drupal\hello_world\HelloWorldSalutation # mappez à une classe à instancier.
    arguments: ['@config.factory', '@event_dispatcher'] # le service responsable du chargement des objets de configuration en peut trouver la definnition en core.services.yml file

  hello_world.redirect_subscriber: # Créons cet abonné en écrivant d'abord sa définition de service Apres create la class.
    class: \Drupal\hello_world\EventSubscriber\HelloWorldRedirectSubscriber
    arguments: ['@current_user', '@current_route_match']
    tags:
      - { name: event_subscriber }

  hello_world.logger.channel.hello_world: # create une canal (MailMessage 1)
    parent: logger.channel_base # clé signifie que notre service héritera de la définition d'un autre service. # dans le service logger.channnel_base au fichier core.services.yml nous voyons également une factory clé. Cela signifie que cette classe de service n'est pas instanciée par le conteneur de service mais par un autre service, à savoir la méthode logger.factorydu service get().
    arguments: ['hello_world']

  # La argumentsclé est également légèrement différente. Tout d'abord, nous n'avons pas le @signe. En effet, ce signe est utilisé pour désigner un nom de service,
  # alors que notre argument est une simple chaîne. En guise de petit plus, si la chaîne est précédée et suivie d'un %, cela indique un paramètre qui peut être
  # défini dans n'importe quel *.services.ymlfichier.
  #
  # Pour revenir à notre exemple, si vous vous souvenez de la théorie de l'enregistreur, cette définition de service signifie que demander ce service effectuera,
  # sous le capot, la tâche suivante:
  #
  #\Drupal::service('logger.factory')->get('hello_world');
  #
  # Il utilise la fabrique d'enregistreurs pour charger un canal avec un certain argument. Donc, maintenant nous pouvons injecter notre
  # hello_world.logger.channel.hello_worldservice et appeler n'importe laquelle des LoggerInterfaceméthodes directement dans notre code client.

  hello_world.logger.hello_world: # save the class as service (MailMessage 3)
    class: Drupal\hello_world\Logger\MailLogger
    tags:                # Cela l'enregistrera en tant que service spécifique recherché par un autre service (appelé collecteur) . J omme nous avons discuté dans le chapitre précédent. Dans ce cas, le collecteur est LoggingChannelFactory.
      - { name: logger }
